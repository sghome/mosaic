<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zoom con Scroll y Cámara Posterior</title>
    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: transparent; /* Establece el color de fondo del cuerpo como transparente */
        }

        #canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
            transition-duration: 150ms;
            box-shadow: 0 5px 20px 5px #00000044;
            position: relative; /* Asegúrate de que el contenedor sea relativo para que los efectos de iluminación sean relativos a él */
            background-color: transparent; /* Establece el color de fondo del contenedor como transparente */
        }

        #canvas-container:hover {
            box-shadow: 0 5px 20px 5px #00000044;
        }

        #canvas-container .glow {
            position: absolute;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
            background-image: radial-gradient(circle at 50% -20%, #ffffff22, #0000000f);
        }

        canvas {
            border-radius: 20px; /* Aplicar bordes circulares al canvas */
            box-shadow: 0px 0px 20px 0px rgba(0,0,0,0.75); /* Efecto de sombra */
            background-color: transparent; /* Establece el color de fondo del canvas como transparente */
        }
    </style>
</head>
<body>
    <a-scene id="canvas-container" id="glow" style="height: 100%; width: 100%;">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
        <script>
            let img;
let canvasWidth, canvasHeight;
let pointCloud = [];
let emojiPositions = [];
let zoom = 0.5; // Zoom inicial
let minZoom = 0.5; // Zoom mínimo
let maxZoom; // Zoom máximo
let offsetX = 0; // Desplazamiento X de la imagen
let offsetY = 0; // Desplazamiento Y de la imagen
let lastMouseX; // Última posición X del mouse al arrastrar
let lastMouseY; // Última posición Y del mouse al arrastrar
let isDragging = false; // Indicador de si se está arrastrando
let animating = true; // Indicador de si se está reproduciendo la animación
let animationStartTime; // Tiempo de inicio de la animación

function preload() {
    img = loadImage("https://cdn.glitch.global/c536c49d-7661-4fd9-81b8-918d12539028/almagua-escuela.jpg");
}

function setup() {
    canvasWidth = min(windowWidth, windowHeight) / 3;
    canvasHeight = canvasWidth;
    maxZoom = 21; // Establece el máximo zoom permitido

    createCanvas(canvasWidth, canvasHeight); // Crear el lienzo

    // Inicializar posiciones de emojis
    for (let y = 0; y < img.height; y++) {
        for (let x = 0; x < img.width; x++) {
            const c = img.get(x, y);
            emojiPositions.push(createVector(x, y));
            pointCloud.push(createVector(x, y)); // Añadir cada punto de la imagen al point cloud
        }
    }

    // Iniciar la animación
    animationStartTime = millis();
}

function draw() {
    background(255); // Establecer el fondo en blanco

    if (animating) {
        animatePointCloud();
    } else {
        drawImage(); // Dibujar la imagen
    }
}

function drawImage() {
    // Dibujar la imagen con el tamaño y desplazamiento adecuados
    image(img, offsetX, offsetY, img.width * zoom, img.height * zoom);
}

function animatePointCloud() {
    if (animating) {
        const time = millis() - animationStartTime;

        for (let i = 0; i < pointCloud.length; i++) {
            // Modificar dinámicamente la posición del point cloud
            pointCloud[i].x += random(-1, 1);
            pointCloud[i].y += random(-1, 1);
        }

        if (time >= 5000) { // Detener la animación después de 5 segundos
            animating = false;
        }
    }
}

function mouseWheel(event) {
    // Ajustar el zoom con la rueda del mouse
    if (mouseX >= 0 && mouseX <= width && mouseY >= 0 && mouseY <= height) {
        zoom -= event.delta * 0.01;
        zoom = constrain(zoom, minZoom, maxZoom);
        return false;
    }
}

function mousePressed() {
    // Iniciar el arrastre de la imagen al presionar el mouse
    if (mouseX >= 0 && mouseX <= width && mouseY >= 0 && mouseY <= height) {
        isDragging = true;
        lastMouseX = mouseX;
        lastMouseY = mouseY;
    }
}

function mouseDragged() {
    // Actualizar el desplazamiento de la imagen mientras se arrastra el mouse
    if (isDragging) {
        let deltaX = mouseX - lastMouseX;
        let deltaY = mouseY - lastMouseY;
        offsetX += deltaX;
        offsetY += deltaY;
        lastMouseX = mouseX;
        lastMouseY = mouseY;
    }
}

function mouseReleased() {
    // Detener el arrastre de la imagen al soltar el mouse
    isDragging = false;
}

function windowResized() {
    // Ajustar el tamaño del lienzo cuando se cambia el tamaño de la ventana
    canvasWidth = min(windowWidth, windowHeight) / 3;
    canvasHeight = canvasWidth;
    resizeCanvas(canvasWidth, canvasHeight);
}

        </script>
        <!-- Vertex Shader -->
        <script id="vertex-shader" type="x-shader/x-vertex">
            attribute vec3 position;
            attribute vec3 normal;
            attribute vec2 uv;
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            varying vec3 vNormal;
            varying vec2 vUv;
            void main() {
                vNormal = normal;
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        </script>

        <!-- Fragment Shader -->
        <script id="fragment-shader" type="x-shader/x-fragment">
            precision highp float;
            varying vec3 vNormal;
            varying vec2 vUv;
            uniform float uTime;
            uniform sampler2D texture;
            void main() {
                vec2 uv = vUv;
                uv.y += sin(uTime * 0.1 + uv.x * 5.0) * 0.01; // Modificar la posición vertical de los píxeles
                uv.x += sin(uTime * 0.1 + uv.y * 5.0) * 0.01; // Modificar la posición horizontal de los píxeles
                gl_FragColor = texture2D(texture, uv);
            }
        </script>
    </a-scene>
</body>
</html>
