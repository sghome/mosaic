<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zoom con Scroll y Cámara Posterior</title>
    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: transparent; /* Establece el color de fondo del cuerpo como transparente */
        }

        #canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
            transition-duration: 150ms;
            box-shadow: 0 5px 20px 5px #00000044;
            position: relative; /* Asegúrate de que el contenedor sea relativo para que los efectos de iluminación sean relativos a él */
            background-color: transparent; /* Establece el color de fondo del contenedor como transparente */
        }

        #canvas-container:hover {
            box-shadow: 0 5px 20px 5px #00000044;
        }

        #canvas-container .glow {
            position: absolute;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
            background-image: radial-gradient(circle at 50% -20%, #ffffff22, #0000000f);
        }

        canvas {
            border-radius: 20px; /* Aplicar bordes circulares al canvas */
            box-shadow: 0px 0px 20px 0px rgba(0,0,0,0.75); /* Efecto de sombra */
            background-color: transparent; /* Establece el color de fondo del canvas como transparente */
        }
    </style>
</head>
<body>
    <a-scene id="canvas-container" id="glow" style="height: 100%; width: 100%;">
        <script>
            let img;
            const pointSize = 3.1;
            let program, renderer;
            let vertices = [];
            let colors = [];
            let emojis = [];
            let emojiPositions = [];
            let zoom = 0.5; // Zoom inicial
            let minZoom = 0.5; // Zoom mínimo
            let maxZoom; // Zoom máximo
            let canvasWidth, canvasHeight;
            let canvas; // Variable para almacenar el canvas
            let offsetX = 0; // Desplazamiento X de la imagen
            let offsetY = 0; // Desplazamiento Y de la imagen
            let lastMouseX; // Última posición X del mouse al arrastrar
            let lastMouseY; // Última posición Y del mouse al arrastrar
            let isDragging = false; // Indicador de si se está arrastrando

            function preload() {
                img = loadImage("cacique-bg.png");
                emojis.push(loadImage("https://cdn.glitch.global/c536c49d-7661-4fd9-81b8-918d12539028/198845101_989500098492476_3555566408394435419_n.jpg"));
                emojis.push(loadImage("https://cdn.glitch.global/c536c49d-7661-4fd9-81b8-918d12539028/333272083_222518770301921_4979215036742286426_n.jpg"));
                emojis.push(loadImage("https://cdn.glitch.global/c536c49d-7661-4fd9-81b8-918d12539028/1605322805490.jpeg"));
                emojis.push(loadImage("https://cdn.glitch.global/c536c49d-7661-4fd9-81b8-918d12539028/13706833_1813943348839850_764687113_a.jpg"));
                emojis.push(loadImage("https://cdn.glitch.global/c536c49d-7661-4fd9-81b8-918d12539028/429311705_779736447350065_4516433906161515358_n.jpg"));
            }

            function setup() {
                renderer = createCanvas(windowWidth, windowHeight, WEBGL);

                const vert = `
                    attribute vec3 aPosition;
                    attribute vec3 aColor;
                    uniform float uTime;
                    uniform mat4 uModelViewMatrix;
                    uniform mat4 uProjectionMatrix;
                    varying vec4 color;
                    void main() {
                        vec3 pos = aPosition;
                        pos.z *= sin(uTime);
                        gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = 1.0;
                        color = vec4(aColor, 1.0);
                    }
                `;

                const frag = `
                    #ifdef GL_ES
                    precision highp float;
                    #endif
                    varying vec4 color;
                    void main() {
                        gl_FragColor = color;
                    }
                `;

                //load shader
                var vs = drawingContext.createShader(drawingContext.VERTEX_SHADER);
                drawingContext.shaderSource(vs, vert);
                drawingContext.compileShader(vs);

                var fs = drawingContext.createShader(drawingContext.FRAGMENT_SHADER);
                drawingContext.shaderSource(fs, frag);
                drawingContext.compileShader(fs);

                //create shader
                program = drawingContext.createProgram();
                drawingContext.attachShader(program, vs);
                drawingContext.attachShader(program, fs);
                drawingContext.linkProgram(program);

                //validate shader
                if (!drawingContext.getShaderParameter(vs, drawingContext.COMPILE_STATUS))
                    console.log(drawingContext.getShaderInfoLog(vs));

                if (!drawingContext.getShaderParameter(fs, drawingContext.COMPILE_STATUS))
                    console.log(drawingContext.getShaderInfoLog(fs));

                if (!drawingContext.getProgramParameter(program, drawingContext.LINK_STATUS))
                    console.log(drawingContext.getProgramInfoLog(program));

                //use shader
                drawingContext.useProgram(program);

                //create uniform pointers
                program.uModelViewMatrix = drawingContext.getUniformLocation(program, "uModelViewMatrix");
                program.uProjectionMatrix = drawingContext.getUniformLocation(program, "uProjectionMatrix");
                program.uTime = drawingContext.getUniformLocation(program, "uTime");

                //enable attributes
                program.aPosition = drawingContext.getAttribLocation(program, "aPosition");
                drawingContext.enableVertexAttribArray(program.aPosition);

                program.aColor = drawingContext.getAttribLocation(program, "aColor");
                drawingContext.enableVertexAttribArray(program.aColor);

                //convert image to buffer data
                const pointScale = 1;
                const xAdd = -img.width / 2;
                const yAdd = -img.height / 2;
                const zAdd = 0;
                for (var y = 0, i = 0; y < img.height; y++) {
                    for (var x = 0; x < img.width; x++) {
                        const c = img.get(x, y);
                        const z = random(-1000, 1000);
                        vertices.push(x * pointScale + xAdd);
                        vertices.push(y * pointScale + yAdd);
                        vertices.push(z * pointScale + zAdd);

                        colors.push(c[0] / 255);
                        colors.push(c[1] / 255);
                        colors.push(c[2] / 255);
                    }
                }

                //create buffers
                program.positionBuffer = drawingContext.createBuffer();
                drawingContext.bindBuffer(drawingContext.ARRAY_BUFFER, program.positionBuffer);
                drawingContext.bufferData(drawingContext.ARRAY_BUFFER, new Float32Array(vertices), drawingContext.STATIC_DRAW);

                program.colorBuffer = drawingContext.createBuffer();
                drawingContext.bindBuffer(drawingContext.ARRAY_BUFFER, program.colorBuffer);
                drawingContext.bufferData(drawingContext.ARRAY_BUFFER, new Float32Array(colors), drawingContext.STATIC_DRAW);

                // Preparar posiciones iniciales para los emojis
                for (let i = 0; i < 1000; i++) {
                    emojiPositions.push(createVector(random(-width / 2, width / 2), random(-height / 2, height / 2)));
                }
            }

            function draw() {
                background(0);
                orbitControl();

                if (vertices.length == 0) return;

                drawingContext.useProgram(program);

                drawingContext.bindBuffer(drawingContext.ARRAY_BUFFER, program.positionBuffer);
                drawingContext.vertexAttribPointer(program.aPosition, 3, drawingContext.FLOAT, false, 0, 0);

                drawingContext.bindBuffer(drawingContext.ARRAY_BUFFER, program.colorBuffer);
                drawingContext.vertexAttribPointer(program.aColor, 3, drawingContext.FLOAT, false, 0, 0);

                drawingContext.uniformMatrix4fv(program.uModelViewMatrix, false, renderer.uMVMatrix.mat4);
                drawingContext.uniformMatrix4fv(program.uProjectionMatrix, false, renderer.uPMatrix.mat4);

                drawingContext.uniform1f(program.uTime, frameCount / 100);

                drawingContext.drawArrays(drawingContext.POINTS, 0, vertices.length / 3);

                // Dibujar emojis
                for (let i = 0; i < emojiPositions.length; i++) {
                    const pos = emojiPositions[i];
                    const emoji = random(emojis);
                    image(emoji, pos.x, pos.y, 50, 50);
                }
            }
        </script>
    </a-scene>
</body>
</html>
